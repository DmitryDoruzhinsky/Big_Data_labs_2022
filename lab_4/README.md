# Лабораторная работа №4 (Введение в ZooKeeper)
В лабораторной работе для реализации на Python была выбрана схожая с ZooKeeper библиотека, а именно [kazoo](https://kazoo.readthedocs.io/en/latest/)
## Задания: 
1. Решите проблему обедающих философов (каждый философ - отдельный процесс в системе)
2. Реализуйте двуфазный коммит протокол для high-available регистра (каждый регистр - отдельный процесс в системе)

Для запуска лабораторной работы проделываем следующие шаги:
1. Запускаем докер-контейнер следующей командой:
```
docker-compose up --build -d
```
примечание: необходимо запустить приложение Docker и далее подождать загрузки необходимых файлов
3. Подготовить среду к работе следующими командами вводимымы в Docker:
```
apt-get update && apt-get install -y python3-distutils python3-apt
```
```
wget https://bootstrap.pypa.io/pip/3.6/get-pip.py
```
```
python3 get-pip.py
```
```
pip install jupyter
```
```
pip install kazoo
```
4. Подключаемся к jupyter notebook следующией командой:
```
jupyter-notebook --ip=0.0.0.0 --port=50001 --allow-root --no-browser
```
5. Заходим по сгенерированному адресу jupyter и производим выполнения заданий лабораторной работы, а именно:</br>

## Задание 1
1. Создаем класс *Philosopher*, в котором содержится описание действий каждого философа(внутри находятся данные ID данного философа и ID соседних, информация о соседних вилках и "путь" до вилок);
![image](https://user-images.githubusercontent.com/83270014/209813548-9e93c24b-b677-4287-88c6-32f38237f03e.png)

2. Лишь один философ может использовать вилки, поэтому необходимо заблокировать стол(общий процесс); 
![image](https://user-images.githubusercontent.com/83270014/209813916-cf033394-6a0c-49f5-aa82-33023eae8aab.png)


3. В течении времени *eat_seconds* будет эмулироваться программа для каждого философа;
![image](https://user-images.githubusercontent.com/83270014/209814137-cb8ca397-848c-4b99-aa6e-9391a2a27ef0.png)


4. Заблокируем вилки если философ поел не больше, чем его соседи и вилки никто не использует 
![image](https://user-images.githubusercontent.com/83270014/209814195-52be2c13-b8e8-487a-adb9-1ba959c07732.png)


5. Использование вилки озночет, что философ есть. После того, как он поест вилки будут свободными, тогда увеличиваем счетчик его еды. Если философ не ест, значит думает.
![image](https://user-images.githubusercontent.com/83270014/209814272-58f9fb43-2bdf-4ce9-9bbc-46c4c02d0b5c.png)

6. Создаем необходимые процессы и задаем константы, также создаем list и записываем результаты.
![image](https://user-images.githubusercontent.com/83270014/209814688-554d70b0-c956-482c-bd2d-54ecd0c0750d.png)

7. Пример результата
![1](https://user-images.githubusercontent.com/83270014/209815547-502e100b-bd16-45c0-86f1-3c785072ddb2.png)



## Задание 2
1. Создадим класс Client, который содержит свой id, путь до своего узла и KazooClient.
![image](https://user-images.githubusercontent.com/83270014/209816020-e44877c3-0a0d-4928-a86c-9c96e5332c5a.png)

2. В методе watch_myself происходит обработка действий, которые приходят от Coordinator - сделать commit, rollback или завершить поток, по причине отсоединия одного из клентов. В коде эта возможность предусмотрена, но не прописано случайное отключение одного из клиентов. </br>В методе run происходит случайный выбор действия ACTION/ROLLBACK, а также происходит запуск функции watch_myself, которая следит за изменениями своего узла. По истечению времени WAIT_HARD_WORK_SEC клиенты завершают свою работу;
![image](https://user-images.githubusercontent.com/83270014/209816174-69e19155-f9a4-4759-8acf-89350de6125b.png)

4. Coordinator следит за работой всех потоков и содержит в себе единственное поле timer, который срабатывает по расписанию;

5. В методе select_action выбирается действие методом голосования и результат выбора отправялется каждому клиенту;
![image](https://user-images.githubusercontent.com/83270014/209816331-fd271c61-9883-46fe-97dd-f53453bd3c6e.png)

6. Метод check_clients получает информацию о клиентах и оповещает других, если один из уже подключенных клиентов отсоединился и говорит им завершить свою работу;
![image](https://user-images.githubusercontent.com/83270014/209816381-7ca58b6f-50a0-44ee-b6b0-c14ff22a35b4.png)

7. Метод watch_clients устанавливает значения в session_logs при первом подключение клиента, а далее происходит обработка количества клиентов.
![image](https://user-images.githubusercontent.com/83270014/209816423-aa98617b-2bce-433c-8869-1b26f990fc61.png)

8. В методе main создается общий процесс и клиенты;
![image](https://user-images.githubusercontent.com/83270014/209816598-51b9b518-37ae-4cc8-bebe-c7b36a315dad.png)
9. Результат. </br>
![image](https://user-images.githubusercontent.com/83270014/209816698-82b3607a-fc5a-4723-b9dd-56cb78918d35.png)
